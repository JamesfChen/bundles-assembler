apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply from: "${rootDir}/script/console.gradle"
android {
    compileSdkVersion Integer.parseInt(rootProject.compileSdkVersion)
    buildToolsVersion rootProject.buildToolsVersion
    defaultConfig {
        (minSdkVersion, targetSdkVersion, versionCode, versionName) = [Integer.parseInt(rootProject.minSdkVersion),
                                                                       Integer.parseInt(rootProject.targetSdkVersion),
                                                                       rootProject.versionCode, rootProject.versionName]

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    ndkVersion '22.0.7026061'
    lintOptions {
        quiet true
        lintConfig project.file("$project.rootDir/lint.xml")
        htmlReport true
        htmlOutput project.file("$project.rootDir/lint-report-${project.name}.html")
        xmlReport true
        xmlOutput project.file("$project.rootDir/lint-report-${project.name}.xml")
        warningsAsErrors true
        abortOnError false
//                // Turns off checks for the issue IDs you specify.
//                disable 'TypographyFractions','TypographyQuotes'
//                // Turns on checks for the issue IDs you specify. These checks are in
//                // addition to the default lint checks.
//                enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'
//                // To enable checks for only a subset of issue IDs and ignore all others,
//                // list the issue IDs with the 'check' property instead. This property overrides
//                // any issue IDs you enable or disable using the properties above.
//                checkOnly 'NewApi', 'InlinedApi'
//                // If set to true, turns off analysis progress reporting by lint.
//                quiet true
//                // if set to true (default), stops the build if errors are found.
//                abortOnError false
//                // if true, only report errors.
//                ignoreWarnings true
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    /**
     * ===============================test start=============================
     */
    //    androidTestImplementation 'androidx.multidex:multidex-instrumentation:2.0.0',{
//        exclude group: 'com.android.support', module: 'multidex'
//    }

    // Dependencies for local unit tests
    testImplementation 'junit:junit:4.12'
//    testImplementation "org.mockito:mockito-all:1.10.19"
//    testImplementation "org.mockito:mockito-core:${rootProject.ext.mockitoVersion}"
//    testImplementation "org.mockito:mockito-inline:${rootProject.ext.mockitoVersion}"
//    testImplementation "org.hamcrest:hamcrest-all:${rootProject.ext.hamcrestVersion}"

    // Espresso dependencies
    androidTestImplementation "androidx.test.espresso:espresso-core:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-contrib:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-intents:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-accessibility:3.1.1"
    androidTestImplementation "androidx.test.espresso:espresso-web:3.1.1"
    androidTestImplementation "androidx.test.espresso.idling:idling-concurrent:3.1.1"
    // The following Espresso dependency can be either "implementation"
    // or "androidTestImplementation", depending on whether you want the
    // dependency to appear on your APK's compile classpath or the test APK
    // classpath.
    androidTestImplementation "androidx.test.espresso:espresso-idling-resource:3.1.1"

    // Dependencies for Android unit tests
    androidTestImplementation "junit:junit:${JUNIT_VERSION}"
    androidTestImplementation "org.mockito:mockito-android:$MOCKITO_VERSION"
    androidTestImplementation 'com.google.dexmaker:dexmaker:1.2'
    androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:1.2'
    androidTestImplementation 'androidx.test.uiautomator:uiautomator-v18:2.2.0-alpha1'

    // Android Testing Support Library's runner and rules
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'
    androidTestImplementation "androidx.test:runner:1.1.1"
    androidTestImplementation "androidx.test:rules:1.1.1"
    androidTestImplementation 'androidx.test:monitor:1.1.0'

    /**
     * ===============================test end=============================
     */
}
def findArtifact() {
    def applicationId = rootProject.applicationId
    def moduleSimpleName = ''
    def moduleCanonicalNmae = ''
    for (def module : gradle.ext.modules) {
        if (project.path == module.sourcePath) {
            moduleSimpleName = module.simpleName
            moduleCanonicalNmae = module.sourcePath
            break
        }
    }
    if ((moduleSimpleName == null || moduleSimpleName.isEmpty())
            || (moduleCanonicalNmae == null || moduleCanonicalNmae.isEmpty())
    ) {
        throw IllegalArgumentException("moduleSimpleName:${moduleSimpleName} :moduleCanonicalNmae${moduleCanonicalNmae} 这两个参数都要配置")
    }
    return [applicationId, moduleSimpleName]
}
def (applicationId, moduleSimpleName) = findArtifact()
apply from: "${rootDir}/script/module_publisher.gradle"
publish {
    name = moduleSimpleName
    groupId = applicationId
    artifactId = moduleSimpleName
    version = "1.0.0"
    website = "https://github.com/JamesfChen/bundles-assembler"
}
ext {
    findModulePath = { simpleName ->
        if (gradle.ext.binaryModuleMap.containsKey(simpleName)) {
            def module = gradle.ext.binaryModuleMap[simpleName]
            if (module.binaryPath.isEmpty()) {
                throw new IllegalArgumentException("binary module 的binaryPath不能为空")
            }
            return module.binaryPath //'com.jamesfchen:box-tool:1.0.0'
        } else if (gradle.ext.sourceModuleMap.containsKey(simpleName)) {
            def module = gradle.ext.sourceModuleMap[simpleName]
            if (module.sourcePath.isEmpty()) {
                throw new IllegalArgumentException("source module 的sourcePath不能为空")
            }
            return module.sourcePath //':framework:common'
        }
        //该模块为exclude，不会进行编译不需要依赖
        return null
    }
    findDeps = { someOne ->
        def myPath
        if (someOne instanceof Project) {
            myPath = someOne.path //source path
        } else {
            myPath = someOne //binary path
        }
        def pickupModule = null
        if (isSourcePath(myPath)) {
            gradle.sourceModuleMap.each { _, m ->
                if (m.sourcePath == myPath) {
                    pickupModule = m
                    return
                }
            }
        } else {
            gradle.binaryModuleMap.each { _, m ->
                if (m.binaryPath == myPath) {
                    pickupModule = m
                    return
                }
            }
        }
        d = []
        if (pickupModule != null) {
            if (pickupModule.deps == null) return []
            pickupModule.deps.each { dep ->
                def path = findModulePath(dep)
                if (path != null) {
                    if (isSourcePath(path)) {
                        path = gradle.rootProject.findProject(path)
                    }
                    d.add(path)
                }
            }
        }
        return d

    }
    findModule = { simpleName ->
        if (gradle.ext.binaryModuleMap.containsKey(simpleName)) {
            return gradle.ext.binaryModuleMap[simpleName]
        } else if (gradle.ext.sourceModuleMap.containsKey(simpleName)) {
            return gradle.ext.sourceModuleMap[simpleName]
        }
        return null
    }
    importDeps = { def myProject, Closure closure ->
        HashSet<String> visited = new HashSet<String>()
        def deps = myProject.findDeps(myProject)
        recurImport(visited, deps, closure)
    }
}
static boolean isSourcePath(def path){
    return !path.contains(".")
}
void recurImport(def visited, def deps, Closure closure) {
    if (deps == null || deps.size() == 0) return
    for (def d : deps) {
        if (d instanceof String) {
            if (!visited.add(d)) {
                continue
            }
        } else if (!visited.add(d.path)) {
            continue
        }
        recurImport(visited, closure.call(d), closure)
    }
}